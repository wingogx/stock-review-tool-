# A股短线复盘工具 - 二期技术方案

**版本**: v2.0
**日期**: 2025-12-10
**状态**: 设计阶段

---

## 一、技术架构概览

### 1.1 整体架构

```
┌──────────────────────────────────────────────┐
│              用户浏览器                       │
│  (Chrome/Edge/Safari)                        │
└─────────────┬────────────────────────────────┘
              │ HTTPS
┌─────────────▼────────────────────────────────┐
│          前端应用 (Next.js 15)                │
│  • 大盘分析页                                 │
│  • 情绪分析页                                 │
│  • 趋势分析页                                 │
│  • K线图组件 (Recharts)                       │
└─────────────┬────────────────────────────────┘
              │ REST API
┌─────────────▼────────────────────────────────┐
│        后端服务 (FastAPI)                     │
│  ┌────────────────────────────────────┐     │
│  │ API层 (新增8个端点)                │     │
│  └────────────┬───────────────────────┘     │
│  ┌────────────▼───────────────────────┐     │
│  │ 业务逻辑层                         │     │
│  │ • MarketAnalysisService            │     │
│  │ • TrendAnalysisService             │     │
│  │ • AIAnalysisService (豆包集成)     │     │
│  └────────────┬───────────────────────┘     │
│  ┌────────────▼───────────────────────┐     │
│  │ 数据采集层                         │     │
│  │ • HistoricalDataCollector (新增)   │     │
│  └────────────┬───────────────────────┘     │
└───────────────┼────────────────────────────┬─┘
                │                            │
    ┌───────────▼────────┐       ┌──────────▼──────┐
    │ Supabase (PostgreSQL)│       │ 豆包API        │
    │ • market_index      │       │ (火山引擎)      │
    │ • market_stats      │       └─────────────────┘
    │ • hot_concepts      │
    │ • limit_stocks      │
    └─────────────────────┘
                │
    ┌───────────▼──────────┐
    │ AKShare (数据源)     │
    │ • 指数历史数据        │
    └──────────────────────┘
```

---

## 二、后端技术方案

### 2.1 新增API端点设计

#### API 1: 指数K线数据

**端点**: `GET /api/market/index/kline`

**参数**:
```python
{
    "days": int = 20,  # 返回天数，默认20
    "index_codes": List[str] = ["SH000001", "SZ399001", "SZ399006"]  # 可选，默认三大指数
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "sh000001": [
            {
                "trade_date": "2025-11-20",
                "open": 3250.12,
                "high": 3268.45,
                "low": 3242.18,
                "close": 3255.67,
                "volume": 50000000000,
                "change_pct": 0.45,
                "amplitude": 0.81
            },
            // ... 19条更多数据
        ],
        "sz399001": [...],
        "sz399006": [...]
    }
}
```

**实现逻辑**:
```python
# backend/app/routers/market.py

@router.get("/index/kline", response_model=KLineResponse)
async def get_index_kline(
    days: int = Query(20, ge=1, le=60),
    index_codes: Optional[List[str]] = Query(None)
):
    """
    获取指数K线数据
    """
    if not index_codes:
        index_codes = ["SH000001", "SZ399001", "SZ399006"]

    supabase = get_supabase()

    # 计算起始日期（考虑周末和节假日，实际需要查询更多天数）
    end_date = get_latest_trading_date()

    result = {}
    for code in index_codes:
        response = supabase.table("market_index").select("*").eq(
            "index_code", code
        ).order("trade_date", desc=True).limit(days).execute()

        # 逆序返回（从旧到新）
        result[code.lower()] = sorted(response.data, key=lambda x: x['trade_date'])

    return KLineResponse(success=True, data=result)
```

---

#### API 2: 市场增强统计

**端点**: `GET /api/market/stats/enhanced`

**响应**:
```json
{
    "success": true,
    "data": {
        "trade_date": "2025-12-09",
        "total_amount_yi": 19057.73,
        "up_count": 1280,
        "down_count": 3801,
        "flat_count": 120,  // 新增
        "limit_up_count": 53,
        "limit_down_count": 7,
        "up_5pct_count": 186,  // 新增：涨幅>5%
        "down_5pct_count": 421,  // 新增：跌幅>5%
        "ladder_distribution": {  // 新增：连板分布
            "1": 21,
            "2": 12,
            "3": 8,
            "4": 6,
            "5": 4,
            "6": 2
        },
        "up_down_ratio": 0.3368,
        "market_status": "弱势"
    }
}
```

**实现逻辑**:
```python
@router.get("/stats/enhanced", response_model=EnhancedStatsResponse)
async def get_enhanced_stats(
    trade_date: Optional[str] = Query(None)
):
    """
    获取增强版市场统计
    """
    if not trade_date:
        trade_date = get_latest_trading_date()

    supabase = get_supabase()

    # 1. 基础统计（从market_stats表）
    base_stats = supabase.table("market_stats").select("*").eq(
        "trade_date", trade_date
    ).single().execute()

    # 2. 计算连板分布（从limit_stocks表）
    limit_stocks = supabase.table("limit_stocks").select(
        "continuous_days"
    ).eq("trade_date", trade_date).eq("is_limit_up", True).execute()

    ladder_distribution = {}
    for stock in limit_stocks.data:
        days = stock['continuous_days'] or 1
        ladder_distribution[str(days)] = ladder_distribution.get(str(days), 0) + 1

    # 3. 计算涨跌幅>5%的股票数（需要查询所有股票数据或从market_sentiment表计算）
    # 这里需要根据实际数据结构调整

    return EnhancedStatsResponse(
        success=True,
        data={
            **base_stats.data,
            "ladder_distribution": ladder_distribution,
            # ...
        }
    )
```

---

#### API 3: AI市场分析

**端点**: `POST /api/ai/market-analysis`

**请求体**:
```json
{
    "trade_date": "2025-12-09"  // 可选，默认最新交易日
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "operability_score": 3.5,  // 1-5分
        "conclusion": "观望为主，小仓位试错",
        "favorable_factors": [
            "板块效应明显（福建自贸区12只涨停）",
            "连板梯队完整（2-6板都有）",
            "CPO概念刚启动，资金关注度高"
        ],
        "unfavorable_factors": [
            "市场情绪偏弱（-3分）",
            "涨跌比1:3，赚钱效应差",
            "炸板率30.3%，资金犹豫"
        ],
        "operation_advice": {
            "position": "≤30%",
            "direction": "福建自贸区、CPO概念低位股",
            "risk_warning": "避开高位连板股，防止炸板",
            "strategy": "快进快出，控制回撤"
        },
        "data_summary": {
            "sentiment_score": -3,
            "sentiment_change": "转弱",
            "up_down_ratio": "1:3",
            "explosion_rate": "30.3%",
            // ...
        }
    }
}
```

**实现逻辑**:
```python
# backend/app/services/ai_service.py

from volcenginesdkarkruntime import Ark
import os
import json

class AIAnalysisService:
    def __init__(self):
        self.api_key = os.getenv("DOUBAO_API_KEY")
        self.model_id = os.getenv("DOUBAO_MODEL_ID", "ep-20241210xxxxx-xxxxx")
        self.client = Ark(api_key=self.api_key)

    async def generate_market_analysis(self, market_data: dict) -> dict:
        """
        生成大盘市场分析

        Args:
            market_data: {
                "sentiment_score": -3,
                "up_count": 1280,
                "down_count": 3801,
                "limit_up_count": 53,
                "explosion_rate": 30.3,
                "hot_concepts": [...],
                "index_changes": {...},
                "ladder_distribution": {...}
            }

        Returns:
            {
                "operability_score": 3.5,
                "conclusion": "...",
                "favorable_factors": [...],
                "unfavorable_factors": [...],
                "operation_advice": {...}
            }
        """
        prompt = self._build_market_prompt(market_data)

        try:
            response = self.client.chat.completions.create(
                model=self.model_id,
                messages=[
                    {
                        "role": "system",
                        "content": "你是一位资深短线交易分析师，擅长分析A股市场情绪和给出操作建议。"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.3,  # 降低随机性，保证分析稳定
                max_tokens=800
            )

            content = response.choices[0].message.content

            # 解析AI返回的结构化数据（要求AI输出JSON格式）
            result = self._parse_market_response(content)

            return result

        except Exception as e:
            logger.error(f"AI分析失败: {str(e)}")
            # 降级方案：返回基于规则的简单分析
            return self._fallback_market_analysis(market_data)

    def _build_market_prompt(self, data: dict) -> str:
        """
        构建市场分析Prompt
        """
        sentiment_score = data.get('sentiment_score', 0)
        up_count = data.get('up_count', 0)
        down_count = data.get('down_count', 0)
        total = up_count + down_count
        up_ratio = (up_count / total * 100) if total > 0 else 0

        hot_concepts_str = "\n".join([
            f"  • {c['concept_name']}: 5日涨幅{c['change_pct']:.2f}%, 涨停{c['limit_up_count']}只"
            for c in data.get('hot_concepts', [])[:5]
        ])

        ladder_str = ", ".join([
            f"{k}板{v}只"
            for k, v in data.get('ladder_distribution', {}).items()
        ])

        prompt = f"""请根据以下A股市场数据，给出今日市场分析：

【市场情绪】
• 情绪评分：{sentiment_score}分（-5到+5分制）
• 涨跌比：{up_count}:{down_count}（上涨占比{up_ratio:.1f}%）
• 涨停数：{data.get('limit_up_count')}只
• 跌停数：{data.get('limit_down_count')}只
• 炸板率：{data.get('explosion_rate', 0):.1f}%

【大盘指数】
• 上证指数：{data.get('index_changes', {}).get('sh000001', 0):.2f}%
• 深证成指：{data.get('index_changes', {}).get('sz399001', 0):.2f}%
• 创业板指：{data.get('index_changes', {}).get('sz399006', 0):.2f}%

【连板梯队】
{ladder_str}

【热门板块】
{hot_concepts_str}

【成交额】
• 今日成交额：{data.get('total_amount_yi', 0):.2f}万亿
• 环比变化：{data.get('amount_change_pct', 0):.2f}%

请按以下JSON格式输出分析结果：
```json
{{
  "operability_score": 3.5,  // 1-5分，精确到0.5，1分=空仓，5分=满仓
  "conclusion": "观望为主，小仓位试错",  // 一句话总结
  "favorable_factors": [  // 3条有利因素，每条≤30字
    "...",
    "...",
    "..."
  ],
  "unfavorable_factors": [  // 3条不利因素，每条≤30字
    "...",
    "...",
    "..."
  ],
  "operation_advice": {{
    "position": "≤30%",  // 建议仓位
    "direction": "福建自贸区、CPO概念低位股",  // 操作方向
    "risk_warning": "避开高位连板股，防止炸板",  // 风险提示
    "strategy": "快进快出，控制回撤"  // 交易策略
  }}
}}
```

要求：
1. 可操作性评分综合考虑市场情绪、赚钱效应、板块强度
2. 有利/不利因素要具体、简洁，直击要害
3. 操作建议要明确可执行，避免模棱两可
4. 严格按照JSON格式输出，不要有额外文字
"""
        return prompt

    def _parse_market_response(self, content: str) -> dict:
        """
        解析AI返回的JSON响应
        """
        try:
            # 提取JSON部分（可能AI会在前后加说明文字）
            start = content.find('{')
            end = content.rfind('}') + 1
            json_str = content[start:end]

            result = json.loads(json_str)

            # 验证必要字段
            assert 'operability_score' in result
            assert 'conclusion' in result
            assert 'favorable_factors' in result
            assert 'unfavorable_factors' in result
            assert 'operation_advice' in result

            return result

        except Exception as e:
            logger.error(f"解析AI响应失败: {str(e)}, content: {content}")
            raise

    def _fallback_market_analysis(self, data: dict) -> dict:
        """
        降级方案：基于规则的简单分析
        """
        sentiment_score = data.get('sentiment_score', 0)

        # 简单规则评分
        if sentiment_score >= 3:
            score = 4.5
            conclusion = "市场强势，可积极参与"
        elif sentiment_score >= 1:
            score = 3.5
            conclusion = "市场偏暖，小仓位试错"
        elif sentiment_score >= -1:
            score = 2.5
            conclusion = "市场中性，观望为主"
        elif sentiment_score >= -3:
            score = 1.5
            conclusion = "市场偏弱，轻仓或空仓"
        else:
            score = 1.0
            conclusion = "市场极弱，建议空仓"

        return {
            "operability_score": score,
            "conclusion": conclusion,
            "favorable_factors": ["板块有热点", "连板梯队完整", "成交额稳定"],
            "unfavorable_factors": ["市场情绪偏弱", "赚钱效应差", "资金谨慎"],
            "operation_advice": {
                "position": f"≤{int(score * 20)}%",
                "direction": "关注热门板块龙头",
                "risk_warning": "控制回撤，快进快出",
                "strategy": "短线为主，见好就收"
            }
        }
```

**API路由**:
```python
# backend/app/routers/ai.py

from fastapi import APIRouter, HTTPException
from app.services.ai_service import AIAnalysisService
from app.schemas.ai import MarketAnalysisResponse

router = APIRouter()
ai_service = AIAnalysisService()

@router.post("/market-analysis", response_model=MarketAnalysisResponse)
async def generate_market_analysis(
    trade_date: Optional[str] = None
):
    """
    生成AI市场分析
    """
    if not trade_date:
        trade_date = get_latest_trading_date()

    # 1. 收集市场数据
    market_data = await collect_market_data(trade_date)

    # 2. 调用AI分析
    analysis = await ai_service.generate_market_analysis(market_data)

    # 3. 添加数据摘要
    analysis['data_summary'] = {
        "sentiment_score": market_data['sentiment_score'],
        "up_down_ratio": f"{market_data['up_count']}:{market_data['down_count']}",
        # ...
    }

    return MarketAnalysisResponse(success=True, data=analysis)
```

---

#### API 4-8: 其他AI分析端点

**类似设计**：
- `POST /api/ai/ladder-health` - 连板梯队健康度
- `POST /api/ai/stock-analysis` - 个股深度分析
- `POST /api/ai/trend-forecast` - 趋势预判
- `GET /api/trend/mainline` - 主线识别（后端算法）
- `GET /api/trend/stocks?concept={name}` - 趋势股票池

（详细设计略，结构类似API 3）

---

### 2.2 数据采集增强

#### 历史指数数据采集

**需求**: 补充market_index表的历史数据（近30日）

**实现**:
```python
# backend/app/services/collectors/historical_data_collector.py

class HistoricalDataCollector:
    """历史数据采集器"""

    def __init__(self):
        self.index_collector = MarketIndexCollector()

    async def collect_index_history(self, days: int = 30):
        """
        采集指数历史数据
        """
        end_date = datetime.now().strftime("%Y-%m-%d")
        start_date = (datetime.now() - timedelta(days=days+10)).strftime("%Y-%m-%d")  # 多采集10天备用

        for symbol in ["sh000001", "sz399001", "sz399006"]:
            logger.info(f"开始采集 {symbol} 近{days}日历史数据...")

            df = self.index_collector.collect_index_daily(
                symbol=symbol,
                start_date=start_date,
                end_date=end_date
            )

            if not df.empty:
                count = self.index_collector.save_to_database(symbol, df)
                logger.info(f"成功保存 {symbol} {count}条历史数据")

            await asyncio.sleep(1)  # 限流
```

**调用时机**:
1. 首次部署时手动执行一次
2. 或者在定时任务中每日检查，补充缺失数据

---

### 2.3 数据库Schema调整

#### market_stats表扩展

```sql
-- 新增字段
ALTER TABLE market_stats ADD COLUMN IF NOT EXISTS flat_count INTEGER DEFAULT 0;
ALTER TABLE market_stats ADD COLUMN IF NOT EXISTS up_5pct_count INTEGER DEFAULT 0;
ALTER TABLE market_stats ADD COLUMN IF NOT EXISTS down_5pct_count INTEGER DEFAULT 0;
ALTER TABLE market_stats ADD COLUMN IF NOT EXISTS ladder_distribution JSONB;

-- 添加注释
COMMENT ON COLUMN market_stats.flat_count IS '平盘股票数';
COMMENT ON COLUMN market_stats.up_5pct_count IS '涨幅>5%股票数';
COMMENT ON COLUMN market_stats.down_5pct_count IS '跌幅>5%股票数';
COMMENT ON COLUMN market_stats.ladder_distribution IS '连板分布 {"1": 21, "2": 12, ...}';
```

#### 新增ai_analysis表（可选，用于缓存AI分析结果）

```sql
CREATE TABLE IF NOT EXISTS ai_analysis (
    id BIGSERIAL PRIMARY KEY,
    trade_date DATE NOT NULL,
    analysis_type VARCHAR(50) NOT NULL,  -- 'market', 'stock', 'trend'
    target VARCHAR(50),  -- 股票代码或概念名称
    analysis_result JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(trade_date, analysis_type, target)
);

CREATE INDEX idx_ai_analysis_date ON ai_analysis(trade_date);
CREATE INDEX idx_ai_analysis_type ON ai_analysis(analysis_type);

COMMENT ON TABLE ai_analysis IS 'AI分析结果缓存表';
```

**作用**：
- 缓存AI分析结果，避免重复调用API
- 节省成本
- 提升响应速度

---

## 三、前端技术方案

### 3.1 页面路由结构

```
/app
├── page.tsx                  # 首页（已有）
├── market-analysis/
│   └── page.tsx              # 大盘分析页（新增）
├── sentiment/
│   └── page.tsx              # 情绪分析页（新增）
├── trend/
│   └── page.tsx              # 趋势分析页（新增）
└── stock/
    └── [code]/
        └── page.tsx          # 个股详情页（后续）
```

### 3.2 组件设计

#### 通用组件

```typescript
// components/ui/Card.tsx（已有）
// components/layout/Header.tsx（已有，需更新导航）

// 新增组件
// components/charts/KLineChart.tsx - K线图
// components/charts/PieChart.tsx - 饼图
// components/charts/BarChart.tsx - 柱状图
// components/ConceptCard.tsx - 概念卡片
// components/StockCard.tsx - 股票卡片
// components/dialogs/ConceptDetailDialog.tsx - 概念详情弹窗
// components/AIAnalysisPanel.tsx - AI分析面板
```

#### K线图组件实现

```tsx
// components/charts/KLineChart.tsx

import { ComposedChart, Line, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface KLineData {
  trade_date: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  ma5?: number;
  ma10?: number;
  ma20?: number;
}

interface KLineChartProps {
  data: KLineData[];
  title: string;
  currentPrice: number;
  changePercent: number;
}

export function KLineChart({ data, title, currentPrice, changePercent }: KLineChartProps) {
  // 计算均线
  const dataWithMA = calculateMovingAverages(data);

  return (
    <div className="space-y-2">
      {/* 标题和当前价格 */}
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">{title}</h3>
        <div className="text-right">
          <div className="text-2xl font-bold">
            {currentPrice.toFixed(2)}
          </div>
          <div className={`text-sm ${changePercent >= 0 ? 'text-red-600' : 'text-green-600'}`}>
            {changePercent >= 0 ? '+' : ''}{changePercent.toFixed(2)}%
          </div>
        </div>
      </div>

      {/* K线图 */}
      <ResponsiveContainer width="100%" height={300}>
        <ComposedChart data={dataWithMA}>
          <XAxis
            dataKey="trade_date"
            tick={{ fontSize: 10 }}
            tickFormatter={(value) => value.slice(5)}  // 只显示MM-DD
          />
          <YAxis
            yAxisId="price"
            domain={['auto', 'auto']}
            tick={{ fontSize: 10 }}
          />
          <YAxis
            yAxisId="volume"
            orientation="right"
            tick={{ fontSize: 10 }}
          />
          <Tooltip
            content={<CustomTooltip />}
          />
          <Legend />

          {/* 成交量柱状图 */}
          <Bar
            yAxisId="volume"
            dataKey="volume"
            fill="#e5e7eb"
            opacity={0.3}
          />

          {/* 均线 */}
          <Line
            yAxisId="price"
            type="monotone"
            dataKey="ma5"
            stroke="#ef4444"
            strokeWidth={1}
            dot={false}
            name="MA5"
          />
          <Line
            yAxisId="price"
            type="monotone"
            dataKey="ma10"
            stroke="#f59e0b"
            strokeWidth={1}
            dot={false}
            name="MA10"
          />
          <Line
            yAxisId="price"
            type="monotone"
            dataKey="ma20"
            stroke="#3b82f6"
            strokeWidth={1}
            dot={false}
            name="MA20"
          />

          {/* 收盘价线 */}
          <Line
            yAxisId="price"
            type="monotone"
            dataKey="close"
            stroke="#10b981"
            strokeWidth={2}
            dot={false}
            name="收盘价"
          />
        </ComposedChart>
      </ResponsiveContainer>

      {/* 趋势判断标签 */}
      <div className="flex gap-2">
        {getTrendTags(data, currentPrice)}
      </div>
    </div>
  );
}

// 计算均线
function calculateMovingAverages(data: KLineData[]): KLineData[] {
  return data.map((item, index) => ({
    ...item,
    ma5: calculateMA(data, index, 5),
    ma10: calculateMA(data, index, 10),
    ma20: calculateMA(data, index, 20),
  }));
}

function calculateMA(data: KLineData[], currentIndex: number, period: number): number {
  if (currentIndex < period - 1) return 0;

  const sum = data
    .slice(currentIndex - period + 1, currentIndex + 1)
    .reduce((acc, item) => acc + item.close, 0);

  return sum / period;
}

// 趋势判断
function getTrendTags(data: KLineData[], currentPrice: number) {
  const latest = data[data.length - 1];
  const tags = [];

  if (latest.ma5 && currentPrice > latest.ma5) {
    tags.push(<span key="trend-up" className="px-2 py-1 text-xs bg-red-100 text-red-600 rounded">短期强势↑</span>);
  } else if (latest.ma10 && currentPrice < latest.ma10) {
    tags.push(<span key="trend-down" className="px-2 py-1 text-xs bg-green-100 text-green-600 rounded">中期转弱↓</span>);
  }

  if (latest.ma20) {
    const support = Math.floor(latest.ma20 / 100) * 100;  // 整数位支撑
    tags.push(<span key="support" className="px-2 py-1 text-xs bg-blue-100 text-blue-600 rounded">支撑: {support}</span>);
  }

  return tags;
}

// 自定义Tooltip
function CustomTooltip({ active, payload }: any) {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;

  return (
    <div className="bg-white p-3 border rounded shadow-lg text-xs">
      <div className="font-semibold mb-2">{data.trade_date}</div>
      <div>开盘: {data.open.toFixed(2)}</div>
      <div>最高: {data.high.toFixed(2)}</div>
      <div>最低: {data.low.toFixed(2)}</div>
      <div>收盘: {data.close.toFixed(2)}</div>
      <div className="mt-2 pt-2 border-t">
        {data.ma5 && <div className="text-red-600">MA5: {data.ma5.toFixed(2)}</div>}
        {data.ma10 && <div className="text-yellow-600">MA10: {data.ma10.toFixed(2)}</div>}
        {data.ma20 && <div className="text-blue-600">MA20: {data.ma20.toFixed(2)}</div>}
      </div>
    </div>
  );
}
```

#### 概念卡片组件

```tsx
// components/ConceptCard.tsx

interface ConceptCardProps {
  concept: {
    concept_name: string;
    change_pct: number;
    day_change_pct: number;
    limit_up_count: number;
    total_count: number;
    concept_strength: number;
    leader_stock_name: string;
    leader_continuous_days: number;
    is_new_concept: boolean;
  };
  onClick: () => void;
}

export function ConceptCard({ concept, onClick }: ConceptCardProps) {
  // 计算星级
  const stars = getStarRating(concept.concept_strength);

  // 背景色
  const bgColor = getBackgroundColor(stars);

  return (
    <div
      className={`${bgColor} rounded-lg p-4 cursor-pointer hover:shadow-lg transition-all`}
      onClick={onClick}
    >
      {/* 标题和星级 */}
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-2">
          <h3 className="text-lg font-semibold text-white">
            {concept.concept_name}
          </h3>
          {concept.is_new_concept && (
            <span className="px-1.5 py-0.5 text-xs bg-red-600 text-white rounded">
              NEW
            </span>
          )}
        </div>
        <div className="text-yellow-300">
          {renderStars(stars)}
        </div>
      </div>

      {/* 涨幅 */}
      <div className="space-y-1 text-white mb-3">
        <div className="text-sm">
          5日涨幅: <span className="text-xl font-bold">{concept.change_pct >= 0 ? '+' : ''}{concept.change_pct.toFixed(2)}%</span>
        </div>
        <div className="text-xs opacity-80">
          今日涨幅: {concept.day_change_pct >= 0 ? '+' : ''}{concept.day_change_pct.toFixed(2)}%
        </div>
      </div>

      {/* 涨停数 */}
      <div className="text-sm text-white mb-3">
        涨停: <span className="font-semibold">{concept.limit_up_count}</span> / {concept.total_count}只
      </div>

      {/* 龙头 */}
      <div className="text-sm text-white mb-3">
        <div className="opacity-80 mb-1">龙头股</div>
        <div className="font-semibold">
          {concept.leader_stock_name}
          {concept.leader_continuous_days > 1 && (
            <span className="ml-2 text-xs">
              {concept.leader_continuous_days}连板
            </span>
          )}
        </div>
      </div>

      {/* 按钮 */}
      <button className="w-full py-2 bg-white/20 hover:bg-white/30 text-white rounded text-sm font-medium transition-colors">
        查看详情
      </button>
    </div>
  );
}

function getStarRating(strength: number): number {
  if (strength >= 8) return 5;
  if (strength >= 6) return 4;
  if (strength >= 4) return 3;
  if (strength >= 2) return 2;
  return 1;
}

function getBackgroundColor(stars: number): string {
  const colors = {
    5: 'bg-gradient-to-br from-red-500 to-red-600',
    4: 'bg-gradient-to-br from-orange-400 to-red-500',
    3: 'bg-gradient-to-br from-yellow-400 to-orange-400',
    2: 'bg-gradient-to-br from-yellow-300 to-gray-400',
    1: 'bg-gray-400',
  };
  return colors[stars as keyof typeof colors];
}

function renderStars(count: number) {
  return '⭐'.repeat(count) + '☆'.repeat(5 - count);
}
```

### 3.3 数据请求封装

```typescript
// lib/api/marketAnalysis.ts

export async function fetchKLineData(days: number = 20) {
  const response = await fetch(`/api/market/index/kline?days=${days}`);
  const data = await response.json();
  return data;
}

export async function fetchAIMarketAnalysis(tradeDate?: string) {
  const response = await fetch('/api/ai/market-analysis', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ trade_date: tradeDate }),
  });
  const data = await response.json();
  return data;
}

export async function fetchEnhancedStats(tradeDate?: string) {
  const url = tradeDate
    ? `/api/market/stats/enhanced?trade_date=${tradeDate}`
    : '/api/market/stats/enhanced';
  const response = await fetch(url);
  const data = await response.json();
  return data;
}
```

```typescript
// hooks/useMarketAnalysis.ts

import { useQuery } from '@tanstack/react-query';
import { fetchKLineData, fetchAIMarketAnalysis, fetchEnhancedStats } from '@/lib/api/marketAnalysis';

export function useKLineData(days: number = 20) {
  return useQuery({
    queryKey: ['kline', days],
    queryFn: () => fetchKLineData(days),
    staleTime: 60000,  // 1分钟内不重新请求
  });
}

export function useAIMarketAnalysis(tradeDate?: string) {
  return useQuery({
    queryKey: ['ai-market-analysis', tradeDate],
    queryFn: () => fetchAIMarketAnalysis(tradeDate),
    staleTime: 300000,  // 5分钟内不重新请求（AI分析相对稳定）
  });
}

export function useEnhancedStats(tradeDate?: string) {
  return useQuery({
    queryKey: ['enhanced-stats', tradeDate],
    queryFn: () => fetchEnhancedStats(tradeDate),
    staleTime: 60000,
  });
}
```

---

## 四、性能优化方案

### 4.1 后端优化

#### 数据库查询优化

```sql
-- 为常用查询添加索引
CREATE INDEX IF NOT EXISTS idx_market_index_code_date
  ON market_index(index_code, trade_date DESC);

CREATE INDEX IF NOT EXISTS idx_hot_concepts_date_strength
  ON hot_concepts(trade_date, concept_strength DESC);

CREATE INDEX IF NOT EXISTS idx_limit_stocks_date_continuous
  ON limit_stocks(trade_date, continuous_days);
```

#### API响应缓存

```python
# 使用Redis缓存K线数据（避免频繁查询数据库）
from redis import Redis
import json

redis_client = Redis(host='localhost', port=6379, db=0)

@router.get("/index/kline")
async def get_index_kline(days: int = 20):
    cache_key = f"kline:{days}"

    # 尝试从缓存读取
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # 查询数据库
    result = await query_database(days)

    # 缓存1分钟
    redis_client.setex(cache_key, 60, json.dumps(result))

    return result
```

### 4.2 前端优化

#### 按需加载组件

```tsx
// 大盘分析页面
import dynamic from 'next/dynamic';

// 动态导入K线图组件（减小首屏加载体积）
const KLineChart = dynamic(() => import('@/components/charts/KLineChart'), {
  loading: () => <div className="h-[300px] bg-gray-100 animate-pulse rounded" />,
  ssr: false,  // K线图不需要服务端渲染
});
```

#### 数据分页

```tsx
// 概念详情弹窗 - 成分股列表分页
const [page, setPage] = useState(1);
const pageSize = 50;

const { data: stocks } = useQuery({
  queryKey: ['concept-stocks', conceptName, page],
  queryFn: () => fetchConceptStocks(conceptName, page, pageSize),
});
```

---

## 五、测试方案

### 5.1 单元测试

**后端测试**（pytest）:
```python
# tests/test_ai_service.py

import pytest
from app.services.ai_service import AIAnalysisService

@pytest.fixture
def ai_service():
    return AIAnalysisService()

@pytest.fixture
def sample_market_data():
    return {
        "sentiment_score": -3,
        "up_count": 1280,
        "down_count": 3801,
        # ...
    }

def test_generate_market_analysis(ai_service, sample_market_data):
    result = await ai_service.generate_market_analysis(sample_market_data)

    assert 'operability_score' in result
    assert 1 <= result['operability_score'] <= 5
    assert 'conclusion' in result
    assert len(result['favorable_factors']) == 3
    assert len(result['unfavorable_factors']) == 3
```

**前端测试**（Jest + React Testing Library）:
```tsx
// __tests__/KLineChart.test.tsx

import { render, screen } from '@testing-library/react';
import { KLineChart } from '@/components/charts/KLineChart';

const mockData = [
  { trade_date: '2025-11-20', open: 3250, high: 3268, low: 3242, close: 3255, volume: 50000000000 },
  // ...
];

test('renders K-line chart with title', () => {
  render(<KLineChart data={mockData} title="上证指数" currentPrice={3255} changePercent={0.45} />);

  expect(screen.getByText('上证指数')).toBeInTheDocument();
  expect(screen.getByText('3255.00')).toBeInTheDocument();
  expect(screen.getByText('+0.45%')).toBeInTheDocument();
});
```

### 5.2 集成测试

**API端到端测试**:
```python
# tests/test_api_integration.py

def test_market_analysis_workflow(client):
    # 1. 获取K线数据
    response = client.get("/api/market/index/kline?days=20")
    assert response.status_code == 200
    kline_data = response.json()
    assert len(kline_data['data']['sh000001']) == 20

    # 2. 获取增强统计
    response = client.get("/api/market/stats/enhanced")
    assert response.status_code == 200
    stats = response.json()
    assert 'ladder_distribution' in stats['data']

    # 3. 生成AI分析
    response = client.post("/api/ai/market-analysis")
    assert response.status_code == 200
    analysis = response.json()
    assert 'operability_score' in analysis['data']
```

### 5.3 性能测试

**压力测试**（Locust）:
```python
# locustfile.py

from locust import HttpUser, task, between

class MarketAnalysisUser(HttpUser):
    wait_time = between(1, 3)

    @task(3)
    def get_kline_data(self):
        self.client.get("/api/market/index/kline?days=20")

    @task(1)
    def get_ai_analysis(self):
        self.client.post("/api/ai/market-analysis")
```

运行测试：
```bash
locust -f locustfile.py --host=http://localhost:8000
# 模拟100个并发用户，持续1分钟
```

---

## 六、部署方案

### 6.1 环境变量配置

```bash
# .env

# 豆包API配置
DOUBAO_API_KEY=your_api_key_here
DOUBAO_MODEL_ID=ep-20241210xxxxx-xxxxx

# Redis缓存（可选）
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# Supabase（已有）
SUPABASE_URL=...
SUPABASE_KEY=...
```

### 6.2 部署流程

#### 后端部署

```bash
# 1. 安装新依赖
pip install volcengine-python-sdk redis

# 2. 运行数据库迁移（如果有Schema变更）
alembic upgrade head

# 3. 采集历史指数数据（首次部署）
python -m app.scripts.collect_historical_data --days=30

# 4. 重启服务
pm2 restart backend
```

#### 前端部署

```bash
# 1. 构建生产版本
cd frontend
npm run build

# 2. 部署到Vercel
vercel --prod
```

### 6.3 监控与告警

**日志监控**:
- 豆包API调用失败率
- API响应时间（P95、P99）
- 数据库查询慢查询

**告警规则**:
- 豆包API失败率 > 5%
- AI分析响应时间 > 5秒
- 数据采集失败

---

## 七、风险控制

### 7.1 AI服务降级

```python
# 豆包API故障时的降级策略

async def generate_market_analysis_with_fallback(market_data: dict) -> dict:
    try:
        # 尝试调用豆包API
        result = await ai_service.generate_market_analysis(market_data)
        return result
    except Exception as e:
        logger.error(f"豆包API调用失败，启用降级方案: {str(e)}")

        # 降级方案1：使用规则引擎
        return generate_rule_based_analysis(market_data)
```

### 7.2 成本控制

**豆包API调用限制**:
- 每个用户每小时最多触发3次AI分析
- 使用缓存减少重复调用
- 预算告警：月成本超过50元发送通知

```python
# 限流装饰器
from functools import wraps
import time

call_history = {}  # {user_id: [timestamp1, timestamp2, ...]}

def rate_limit(max_calls=3, period=3600):
    def decorator(func):
        @wraps(func)
        async def wrapper(user_id, *args, **kwargs):
            now = time.time()
            history = call_history.get(user_id, [])

            # 清理过期记录
            history = [t for t in history if now - t < period]

            if len(history) >= max_calls:
                raise HTTPException(
                    status_code=429,
                    detail=f"调用过于频繁，请{period//60}分钟后再试"
                )

            history.append(now)
            call_history[user_id] = history

            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

---

## 八、时间排期

### Phase 1: 基础设施（2天）
- [ ] 后端安装豆包SDK
- [ ] 配置环境变量
- [ ] 数据库Schema调整
- [ ] 采集历史指数数据

### Phase 2: 大盘分析页面（5天）
- [ ] 后端API开发（K线、增强统计、AI分析）
- [ ] 前端K线图组件
- [ ] 前端页面布局
- [ ] 热门板块TOP10卡片
- [ ] 概念详情弹窗
- [ ] 联调测试

### Phase 3: 情绪分析页面（3天）
- [ ] 后端API（连板分组、个股AI分析）
- [ ] 前端页面开发
- [ ] 测试

### Phase 4: 趋势分析页面（3天）
- [ ] 后端主线识别算法
- [ ] 后端趋势预判API
- [ ] 前端页面开发
- [ ] 测试

### Phase 5: 优化与上线（1天）
- [ ] 性能测试
- [ ] Bug修复
- [ ] 文档更新
- [ ] 部署上线

**总计**: 14天（2周）

---

**文档状态**: ✅ 待评审
**下一步**: 编写开发计划文档
