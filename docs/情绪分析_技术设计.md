# 情绪分析页面 - 技术设计文档

**版本**: v1.0
**日期**: 2025-12-12
**状态**: 待开发

---

## 一、现有数据资源

### 1.1 数据库表

#### limit_stocks_detail（涨停股详情）

```sql
-- 已有字段，可直接使用
id, trade_date, stock_code, stock_name, limit_type,
change_pct,           -- 涨跌幅
close_price,          -- 收盘价
turnover_rate,        -- 换手率
amount,               -- 成交额
first_limit_time,     -- 首次封板时间
last_limit_time,      -- 最后封板时间
continuous_days,      -- 连板天数
opening_times,        -- 开板次数（烂板）
sealed_amount,        -- 封单金额
is_st,                -- 是否ST
is_strong_limit,      -- 是否强势涨停
concepts,             -- 所属概念（JSON数组）
concepts_str,         -- 所属概念（字符串）
industry,             -- 所属行业
main_net_inflow,      -- 主力净流入
main_net_inflow_pct,  -- 主力净流入占比
market_cap,           -- 总市值
circulation_market_cap -- 流通市值
```

#### market_sentiment（市场情绪）

```sql
-- 已有字段，可直接使用
trade_date,
limit_up_count,                    -- 涨停数
limit_down_count,                  -- 跌停数
continuous_limit_distribution,     -- 连板分布 {"1": 21, "2": 12, "3": 8, ...}
prev_continuous_limit_distribution, -- 昨日连板分布
prev2_continuous_limit_distribution, -- 前日连板分布
explosion_rate                     -- 炸板率
```

### 1.2 现有API

| API | 说明 | 可复用 |
|-----|------|--------|
| `/api/market/sentiment` | 市场情绪数据 | ✅ 炸板率、连板分布 |
| `/api/limit-stocks/stocks` | 涨停股列表 | ✅ 龙头股数据 |
| `/api/concepts/hot` | 热门概念 | ✅ 概念涨跌幅 |

---

## 二、新增API设计

### 2.1 API总览

| API | 方法 | 说明 |
|-----|------|------|
| `/api/sentiment/analysis` | GET | 情绪分析完整数据（合并接口） |

### 2.2 接口详细设计

#### GET /api/sentiment/analysis

**请求参数**：
```
trade_date: string (可选，默认最新交易日，格式 YYYY-MM-DD)
```

**响应结构**：
```json
{
  "success": true,
  "trade_date": "2025-12-11",
  "data": {
    // 模块1：情绪周期仪表盘
    "emotion_dashboard": {
      "space_height": 6,                    // 空间板高度
      "limit_up_count": 53,                 // 涨停数
      "limit_up_change": -21,               // 涨停数变化
      "explosion_rate": 28.3,               // 炸板率
      "overall_promotion_rate": 42.5,       // 整体晋级率
      "promotion_details": [                // 分层晋级率
        {"from": 1, "to": 2, "yesterday": 21, "today": 8, "rate": 38.1},
        {"from": 2, "to": 3, "yesterday": 8, "today": 4, "rate": 50.0},
        {"from": 3, "to": 4, "yesterday": 6, "today": 4, "rate": 66.7}
      ],
      "emotion_stage": "加速期",            // 情绪阶段
      "emotion_stage_color": "orange"       // 阶段颜色
    },

    // 模块2：昨日涨停表现
    "yesterday_performance": {
      "yesterday_limit_up_count": 53,       // 昨日涨停数
      "today_avg_change": 1.2,              // 今日平均涨幅
      "up_count": 32,                       // 上涨家数
      "down_count": 21,                     // 下跌家数
      "big_loss_count": 8,                  // 大面数量（跌>5%）
      "big_loss_rate": 15.1,                // 大面率
      "big_loss_stocks": [                  // 大面个股列表
        {
          "stock_code": "600XXX",
          "stock_name": "XX股份",
          "today_change_pct": -7.2,
          "yesterday_continuous_days": 1,   // 昨日连板数（1=首板）
          "concepts": ["商业航天"]
        }
      ]
    },

    // 模块3：概念梯队分析（空间板≥4板时才有数据）
    "concept_ladder": {
      "available": true,                    // 是否可用（空间板≥4板）
      "concepts": [
        {
          "concept_name": "商业航天",
          "max_continuous_days": 6,         // 最高连板数
          "total_limit_up_count": 19,       // 涨停总数
          "concept_change_pct": 3.2,        // 板块涨幅
          "ladder_status": "complete",      // 梯队状态: complete/normal/alone
          "ladder": [                       // 梯队分布
            {"days": 6, "count": 1, "stocks": ["XX股份"]},
            {"days": 4, "count": 2, "stocks": ["YY科技", "ZZ实业"]},
            {"days": 3, "count": 3, "stocks": ["AA电子", "BB控股", "CC科技"]},
            {"days": 2, "count": 5, "stocks": ["..."]}
          ]
        },
        {
          "concept_name": "福建自贸区",
          "max_continuous_days": 6,
          "total_limit_up_count": 1,
          "ladder_status": "alone",         // 独苗警告
          "ladder": [
            {"days": 6, "count": 1, "stocks": ["安记食品"]}
          ]
        }
      ]
    },

    // 模块4：龙头股深度分析
    "leader_analysis": [
      {
        "stock_code": "600XXX",
        "stock_name": "XX股份",
        "continuous_days": 6,
        "is_top": true,                     // 是否高标
        "concepts": ["商业航天", "军工"],
        "industry": "航天航空",

        // 技术面
        "technical": {
          "first_limit_time": "09:32:15",
          "first_limit_time_level": "strong", // strong/normal/weak
          "last_limit_time": "09:32:15",
          "opening_times": 0,
          "opening_times_level": "strong",
          "turnover_rate": 18.5,
          "turnover_rate_level": "normal",
          "amount": 850000000                 // 8.5亿
        },

        // 资金面
        "capital": {
          "main_net_inflow": 230000000,       // 2.3亿
          "main_net_inflow_level": "strong",
          "main_net_inflow_pct": 12.5,
          "sealed_amount": 520000000,         // 5.2亿
          "sealed_ratio": 61.2,               // 封单/成交比
          "sealed_ratio_level": "strong"
        },

        // 梯队情况
        "ladder": {
          "concept_name": "商业航天",
          "status": "complete",
          "follower_count": 18,               // 跟风股数
          "ladder_detail": [
            {"days": 4, "count": 2, "stocks": ["YY科技", "ZZ实业"]},
            {"days": 3, "count": 3, "stocks": ["AA电子", "BB控股", "CC科技"]}
          ]
        },

        // 综合评估
        "evaluation": {
          "positive_factors": [
            "早盘秒板，未开板，强势",
            "主力资金净流入2.3亿",
            "板块梯队完整，有跟风"
          ],
          "negative_factors": [
            "6连板高位，溢价空间有限",
            "换手率18.5%，有获利盘"
          ],
          "conclusion": "opportunity",        // opportunity/neutral/risk
          "conclusion_text": "机会 > 风险，但需警惕高开低走"
        }
      }
    ]
  }
}
```

---

## 三、后端实现

### 3.1 新增文件

```
backend/app/
├── routers/
│   └── sentiment.py          # 情绪分析路由（新增）
├── schemas/
│   └── sentiment.py          # 数据模型（新增）
└── services/
    └── sentiment_service.py  # 业务逻辑（新增）
```

### 3.2 路由实现

```python
# backend/app/routers/sentiment.py

from fastapi import APIRouter, Query
from typing import Optional

from app.schemas.sentiment import SentimentAnalysisResponse
from app.services.sentiment_service import SentimentService

router = APIRouter(prefix="/api/sentiment", tags=["情绪分析"])

@router.get("/analysis", response_model=SentimentAnalysisResponse)
async def get_sentiment_analysis(
    trade_date: Optional[str] = Query(None, description="交易日期 YYYY-MM-DD")
):
    """
    获取情绪分析完整数据

    包含：
    - 情绪周期仪表盘（空间板、晋级率、炸板率、情绪阶段）
    - 昨日涨停表现（大面率、大面个股）
    - 概念梯队分析（空间板≥4板时展示）
    - 龙头股深度分析（4板+龙头）
    """
    service = SentimentService()
    return await service.get_analysis(trade_date)
```

### 3.3 业务逻辑实现

```python
# backend/app/services/sentiment_service.py

from typing import Optional, List, Dict
from app.utils.supabase_client import get_supabase
from app.utils.trading_date import get_latest_trading_date, get_previous_trading_date

class SentimentService:

    def __init__(self):
        self.supabase = get_supabase()

    async def get_analysis(self, trade_date: Optional[str] = None):
        if not trade_date:
            trade_date = get_latest_trading_date()

        yesterday = get_previous_trading_date(trade_date)

        # 并行获取数据
        emotion_dashboard = await self._get_emotion_dashboard(trade_date, yesterday)
        yesterday_performance = await self._get_yesterday_performance(trade_date, yesterday)
        concept_ladder = await self._get_concept_ladder(trade_date)
        leader_analysis = await self._get_leader_analysis(trade_date)

        return {
            "success": True,
            "trade_date": trade_date,
            "data": {
                "emotion_dashboard": emotion_dashboard,
                "yesterday_performance": yesterday_performance,
                "concept_ladder": concept_ladder,
                "leader_analysis": leader_analysis
            }
        }

    async def _get_emotion_dashboard(self, trade_date: str, yesterday: str) -> dict:
        """获取情绪周期仪表盘数据"""
        # 1. 获取今日市场情绪
        today_sentiment = self.supabase.table("market_sentiment")\
            .select("*").eq("trade_date", trade_date).execute()

        # 2. 获取昨日市场情绪
        yesterday_sentiment = self.supabase.table("market_sentiment")\
            .select("*").eq("trade_date", yesterday).execute()

        # 3. 计算空间板高度
        today_distribution = today_sentiment.data[0].get("continuous_limit_distribution", {})
        space_height = max([int(k) for k in today_distribution.keys()]) if today_distribution else 0

        # 4. 计算晋级率
        yesterday_distribution = yesterday_sentiment.data[0].get("continuous_limit_distribution", {}) if yesterday_sentiment.data else {}
        promotion_details = self._calculate_promotion_rate(today_distribution, yesterday_distribution)

        # 5. 判断情绪阶段
        explosion_rate = today_sentiment.data[0].get("explosion_rate", 0)
        emotion_stage, stage_color = self._determine_emotion_stage(space_height, explosion_rate, promotion_details)

        return {
            "space_height": space_height,
            "limit_up_count": today_sentiment.data[0].get("limit_up_count", 0),
            "explosion_rate": explosion_rate,
            "promotion_details": promotion_details,
            "emotion_stage": emotion_stage,
            "emotion_stage_color": stage_color
        }

    async def _get_yesterday_performance(self, trade_date: str, yesterday: str) -> dict:
        """获取昨日涨停今日表现"""
        # 1. 获取昨日涨停股
        yesterday_stocks = self.supabase.table("limit_stocks_detail")\
            .select("stock_code, stock_name, continuous_days, concepts")\
            .eq("trade_date", yesterday)\
            .eq("limit_type", "limit_up")\
            .execute()

        if not yesterday_stocks.data:
            return {"yesterday_limit_up_count": 0, "big_loss_count": 0, "big_loss_rate": 0}

        # 2. 获取这些股票今日的涨跌幅（需要关联查询或外部API）
        # 这里需要调用行情接口获取今日涨跌幅
        # 暂时使用limit_stocks_detail今日数据作为参考
        today_stocks = self.supabase.table("limit_stocks_detail")\
            .select("stock_code, change_pct")\
            .eq("trade_date", trade_date)\
            .execute()

        today_map = {s["stock_code"]: s["change_pct"] for s in today_stocks.data}

        # 3. 统计
        up_count = 0
        down_count = 0
        big_loss_stocks = []
        total_change = 0

        for stock in yesterday_stocks.data:
            # TODO: 这里需要获取非涨停股今日涨跌幅，暂用模拟逻辑
            change_pct = today_map.get(stock["stock_code"], 0)
            total_change += change_pct

            if change_pct > 0:
                up_count += 1
            else:
                down_count += 1

            if change_pct < -5:
                big_loss_stocks.append({
                    "stock_code": stock["stock_code"],
                    "stock_name": stock["stock_name"],
                    "today_change_pct": change_pct,
                    "yesterday_continuous_days": stock["continuous_days"],
                    "concepts": stock.get("concepts", [])[:1]  # 取第一个概念
                })

        yesterday_count = len(yesterday_stocks.data)

        return {
            "yesterday_limit_up_count": yesterday_count,
            "today_avg_change": round(total_change / yesterday_count, 2) if yesterday_count > 0 else 0,
            "up_count": up_count,
            "down_count": down_count,
            "big_loss_count": len(big_loss_stocks),
            "big_loss_rate": round(len(big_loss_stocks) / yesterday_count * 100, 1) if yesterday_count > 0 else 0,
            "big_loss_stocks": sorted(big_loss_stocks, key=lambda x: x["today_change_pct"])[:10]
        }

    async def _get_concept_ladder(self, trade_date: str) -> dict:
        """获取概念梯队分析"""
        # 1. 获取今日所有涨停股
        stocks = self.supabase.table("limit_stocks_detail")\
            .select("stock_code, stock_name, continuous_days, concepts, concepts_str")\
            .eq("trade_date", trade_date)\
            .eq("limit_type", "limit_up")\
            .gte("continuous_days", 2)\
            .execute()

        # 2. 判断空间板高度
        max_days = max([s["continuous_days"] for s in stocks.data]) if stocks.data else 0

        if max_days < 4:
            return {"available": False, "concepts": []}

        # 3. 筛选4板+股票并按概念分组
        high_stocks = [s for s in stocks.data if s["continuous_days"] >= 4]

        # 按概念分组
        concept_map = {}
        for stock in stocks.data:
            concepts = stock.get("concepts") or []
            if isinstance(concepts, str):
                concepts = [concepts]

            for concept in concepts:
                if concept not in concept_map:
                    concept_map[concept] = []
                concept_map[concept].append(stock)

        # 4. 只保留有4板+股票的概念
        result_concepts = []
        for concept, concept_stocks in concept_map.items():
            max_continuous = max([s["continuous_days"] for s in concept_stocks])
            if max_continuous < 4:
                continue

            # 构建梯队分布
            ladder = {}
            for stock in concept_stocks:
                days = stock["continuous_days"]
                if days not in ladder:
                    ladder[days] = []
                ladder[days].append(stock["stock_name"])

            ladder_list = [
                {"days": days, "count": len(names), "stocks": names}
                for days, names in sorted(ladder.items(), reverse=True)
            ]

            # 判断梯队状态
            total_count = len(concept_stocks)
            if total_count == 1:
                status = "alone"
            elif total_count >= 3 and len(ladder) >= 2:
                status = "complete"
            else:
                status = "normal"

            result_concepts.append({
                "concept_name": concept,
                "max_continuous_days": max_continuous,
                "total_limit_up_count": total_count,
                "ladder_status": status,
                "ladder": ladder_list
            })

        # 按最高连板数排序
        result_concepts.sort(key=lambda x: (-x["max_continuous_days"], -x["total_limit_up_count"]))

        return {"available": True, "concepts": result_concepts}

    async def _get_leader_analysis(self, trade_date: str) -> list:
        """获取龙头股深度分析"""
        # 1. 获取4板+龙头股
        leaders = self.supabase.table("limit_stocks_detail")\
            .select("*")\
            .eq("trade_date", trade_date)\
            .eq("limit_type", "limit_up")\
            .gte("continuous_days", 4)\
            .order("continuous_days", desc=True)\
            .execute()

        if not leaders.data:
            return []

        max_days = leaders.data[0]["continuous_days"]

        result = []
        for stock in leaders.data:
            # 技术面分析
            technical = self._analyze_technical(stock)

            # 资金面分析
            capital = self._analyze_capital(stock)

            # 梯队分析（获取同概念其他涨停股）
            ladder = await self._get_stock_ladder(trade_date, stock)

            # 综合评估
            evaluation = self._evaluate_leader(stock, technical, capital, ladder)

            result.append({
                "stock_code": stock["stock_code"],
                "stock_name": stock["stock_name"],
                "continuous_days": stock["continuous_days"],
                "is_top": stock["continuous_days"] == max_days,
                "concepts": stock.get("concepts", []),
                "industry": stock.get("industry", ""),
                "technical": technical,
                "capital": capital,
                "ladder": ladder,
                "evaluation": evaluation
            })

        return result

    def _analyze_technical(self, stock: dict) -> dict:
        """分析技术面"""
        first_time = stock.get("first_limit_time", "")
        opening_times = stock.get("opening_times", 0)
        turnover_rate = stock.get("turnover_rate", 0)

        # 首封时间评级
        if first_time and first_time < "10:00:00":
            first_time_level = "strong"
        elif first_time and first_time < "13:30:00":
            first_time_level = "normal"
        else:
            first_time_level = "weak"

        # 开板次数评级
        if opening_times == 0:
            opening_level = "strong"
        elif opening_times <= 1:
            opening_level = "normal"
        else:
            opening_level = "weak"

        # 换手率评级
        if turnover_rate and turnover_rate < 20:
            turnover_level = "strong"
        elif turnover_rate and turnover_rate < 35:
            turnover_level = "normal"
        else:
            turnover_level = "weak"

        return {
            "first_limit_time": first_time,
            "first_limit_time_level": first_time_level,
            "last_limit_time": stock.get("last_limit_time", ""),
            "opening_times": opening_times,
            "opening_times_level": opening_level,
            "turnover_rate": turnover_rate,
            "turnover_rate_level": turnover_level,
            "amount": stock.get("amount", 0)
        }

    def _analyze_capital(self, stock: dict) -> dict:
        """分析资金面"""
        main_inflow = stock.get("main_net_inflow", 0) or 0
        main_inflow_pct = stock.get("main_net_inflow_pct", 0) or 0
        sealed_amount = stock.get("sealed_amount", 0) or 0
        amount = stock.get("amount", 1)

        # 主力净流入评级
        if main_inflow > 0 and main_inflow_pct > 10:
            inflow_level = "strong"
        elif main_inflow > 0:
            inflow_level = "normal"
        else:
            inflow_level = "weak"

        # 封单比评级
        sealed_ratio = (sealed_amount / amount * 100) if amount > 0 else 0
        if sealed_ratio > 50:
            sealed_level = "strong"
        elif sealed_ratio > 20:
            sealed_level = "normal"
        else:
            sealed_level = "weak"

        return {
            "main_net_inflow": main_inflow,
            "main_net_inflow_level": inflow_level,
            "main_net_inflow_pct": main_inflow_pct,
            "sealed_amount": sealed_amount,
            "sealed_ratio": round(sealed_ratio, 1),
            "sealed_ratio_level": sealed_level
        }

    async def _get_stock_ladder(self, trade_date: str, stock: dict) -> dict:
        """获取股票所属概念的梯队情况"""
        concepts = stock.get("concepts", [])
        if not concepts:
            return {"status": "alone", "follower_count": 0}

        main_concept = concepts[0] if isinstance(concepts, list) else concepts

        # 查询同概念其他涨停股
        # 注意：这里简化处理，实际需要按concepts字段查询
        all_stocks = self.supabase.table("limit_stocks_detail")\
            .select("stock_code, stock_name, continuous_days")\
            .eq("trade_date", trade_date)\
            .eq("limit_type", "limit_up")\
            .execute()

        # 筛选同概念股票
        same_concept_stocks = []
        for s in all_stocks.data:
            if s["stock_code"] == stock["stock_code"]:
                continue
            s_concepts = s.get("concepts", [])
            if main_concept in (s_concepts if isinstance(s_concepts, list) else [s_concepts]):
                same_concept_stocks.append(s)

        if not same_concept_stocks:
            return {
                "concept_name": main_concept,
                "status": "alone",
                "follower_count": 0,
                "ladder_detail": []
            }

        # 构建梯队
        ladder = {}
        for s in same_concept_stocks:
            days = s["continuous_days"]
            if days not in ladder:
                ladder[days] = []
            ladder[days].append(s["stock_name"])

        ladder_detail = [
            {"days": days, "count": len(names), "stocks": names[:3]}
            for days, names in sorted(ladder.items(), reverse=True)
        ]

        status = "complete" if len(same_concept_stocks) >= 2 else "normal"

        return {
            "concept_name": main_concept,
            "status": status,
            "follower_count": len(same_concept_stocks),
            "ladder_detail": ladder_detail
        }

    def _evaluate_leader(self, stock: dict, technical: dict, capital: dict, ladder: dict) -> dict:
        """综合评估龙头"""
        positive = []
        negative = []

        # 技术面评估
        if technical["first_limit_time_level"] == "strong":
            positive.append("早盘封板，强势")
        elif technical["first_limit_time_level"] == "weak":
            negative.append("尾盘封板，弱势")

        if technical["opening_times_level"] == "strong":
            positive.append("未开板，封单稳固")
        elif technical["opening_times_level"] == "weak":
            negative.append(f"开板{technical['opening_times']}次，烂板")

        if technical["turnover_rate_level"] == "weak":
            negative.append(f"换手率{technical['turnover_rate']:.1f}%，获利盘多")

        # 资金面评估
        if capital["main_net_inflow_level"] == "strong":
            positive.append(f"主力净流入{capital['main_net_inflow']/100000000:.1f}亿")
        elif capital["main_net_inflow_level"] == "weak":
            negative.append("主力资金流出")

        if capital["sealed_ratio_level"] == "strong":
            positive.append(f"封单强，封单比{capital['sealed_ratio']:.0f}%")
        elif capital["sealed_ratio_level"] == "weak":
            negative.append("封单弱，易炸板")

        # 梯队评估
        if ladder["status"] == "complete":
            positive.append("板块梯队完整，有跟风")
        elif ladder["status"] == "alone":
            negative.append("独苗，无跟风")

        # 高位风险
        if stock["continuous_days"] >= 5:
            negative.append(f"{stock['continuous_days']}连板高位，溢价空间有限")

        # 综合判断
        if len(positive) > len(negative):
            conclusion = "opportunity"
            conclusion_text = "机会 > 风险"
        elif len(positive) < len(negative):
            conclusion = "risk"
            conclusion_text = "风险 > 机会"
        else:
            conclusion = "neutral"
            conclusion_text = "机会与风险并存"

        return {
            "positive_factors": positive,
            "negative_factors": negative,
            "conclusion": conclusion,
            "conclusion_text": conclusion_text
        }

    def _calculate_promotion_rate(self, today: dict, yesterday: dict) -> list:
        """计算分层晋级率"""
        result = []
        for n in range(1, 10):
            yesterday_count = yesterday.get(str(n), 0)
            today_count = today.get(str(n + 1), 0)

            if yesterday_count > 0:
                rate = round(today_count / yesterday_count * 100, 1)
                result.append({
                    "from": n,
                    "to": n + 1,
                    "yesterday": yesterday_count,
                    "today": today_count,
                    "rate": rate
                })

        return result

    def _determine_emotion_stage(self, space_height: int, explosion_rate: float, promotion_details: list) -> tuple:
        """判断情绪周期阶段"""
        avg_rate = sum([p["rate"] for p in promotion_details]) / len(promotion_details) if promotion_details else 0

        if space_height <= 3 and explosion_rate > 50:
            return ("冰点期", "blue")
        elif space_height == 4 or (space_height >= 4 and avg_rate < 30):
            return ("回暖期", "yellow")
        elif space_height in [5, 6] and avg_rate >= 40:
            return ("加速期", "orange")
        elif space_height >= 7:
            return ("高潮期", "red")
        else:
            return ("退潮期", "green")
```

---

## 四、前端实现

### 4.1 新增文件

```
frontend/
├── app/
│   └── sentiment/
│       └── page.tsx          # 情绪分析页面
├── components/
│   └── sentiment/
│       ├── EmotionDashboard.tsx    # 情绪仪表盘组件
│       ├── YesterdayPerformance.tsx # 昨日涨停表现组件
│       ├── ConceptLadder.tsx       # 概念梯队组件
│       └── LeaderAnalysis.tsx      # 龙头分析组件
└── types/
    └── sentiment.ts          # 类型定义
```

### 4.2 页面结构

```tsx
// frontend/app/sentiment/page.tsx

'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { EmotionDashboard } from '@/components/sentiment/EmotionDashboard';
import { YesterdayPerformance } from '@/components/sentiment/YesterdayPerformance';
import { ConceptLadder } from '@/components/sentiment/ConceptLadder';
import { LeaderAnalysis } from '@/components/sentiment/LeaderAnalysis';

export default function SentimentPage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['sentimentAnalysis'],
    queryFn: async () => {
      const response = await apiClient.get('/api/sentiment/analysis');
      return response.data;
    },
  });

  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>加载失败</div>;

  return (
    <main className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* 模块1：情绪周期仪表盘 */}
        <EmotionDashboard data={data.data.emotion_dashboard} />

        {/* 模块2：昨日涨停表现 */}
        <YesterdayPerformance data={data.data.yesterday_performance} />

        {/* 模块3：概念梯队分析 */}
        <ConceptLadder data={data.data.concept_ladder} />

        {/* 模块4：龙头股深度分析 */}
        <LeaderAnalysis data={data.data.leader_analysis} />
      </div>
    </main>
  );
}
```

---

## 五、数据依赖说明

### 5.1 昨日涨停今日表现的数据问题

**问题**：`limit_stocks_detail` 表只存涨停股，非涨停股今日涨跌幅无法直接获取

**解决方案**：
1. **方案A**：调用 Tushare 行情接口获取今日涨跌幅（推荐）
2. **方案B**：新增每日行情表，采集所有股票涨跌幅
3. **方案C**：简化处理，只统计昨日涨停股中今日仍涨停的表现

**建议**：先用方案C快速实现，后续优化为方案A

### 5.2 概念归属问题

**问题**：一只股票可能属于多个概念，如何确定主概念？

**解决方案**：
1. 取 `concepts` 数组的第一个作为主概念
2. 或者取当日涨幅最高的概念
3. 或者取涨停数最多的概念

**建议**：先用第一个概念，后续可优化

---

## 六、注册路由

```python
# backend/app/main.py

from app.routers import sentiment

app.include_router(sentiment.router)
```
